<div id="calendar"></div>

<%- include('../_components/password-modal.html') %>
<%- include('../_components/toast.html') %>
<%- include('../_components/confirm-modal.html') %>
<%- include('../_components/calendar-modals.html') %>
<%- include('../_components/event-modal.html') %>



<script>
    let calendar;
    let eventSources = [];
    let isAuthenticated = false;

    function initCalendar() {
        const calendarEl = document.getElementById('calendar');

        const urlParams = new URLSearchParams(window.location.search);
        const viewParam = urlParams.get('view');
        const dateParam = urlParams.get('date');

        let initialView = 'timeGridWeek';
        if (viewParam) {
            switch (viewParam) {
                case 'month':
                    initialView = 'dayGridMonth';
                    break;
                case 'week':
                    initialView = 'timeGridWeek';
                    break;
                case 'day':
                    initialView = 'timeGridDay';
                    break;
                case 'list':
                    initialView = 'listMonth';
                    break;
            }
        }

        calendar = new FullCalendar.Calendar(calendarEl, {
            initialView: initialView,
            initialDate: dateParam || undefined,
            firstDay: 1,
            headerToolbar: {
                left: 'prev,next today',
                center: 'title',
                right: 'dayGridMonth,timeGridWeek,timeGridDay,listMonth refetchButton settingsButton'
            },
            customButtons: {
                refetchButton: {
                    text: 'refetch',
                    hint: 'Refetch All Calendars',
                    click: function () {
                        refetchAllCalendars();
                    }
                },
                settingsButton: {
                    text: 'settings',
                    hint: 'Manage Calendars',
                    click: function () {
                        if (isAuthenticated) {
                            calendarModals.management.show();
                        } else {
                            passwordModal.show();
                        }
                    }
                }
            },
            height: '100%',
            nowIndicator: true,
            expandRows: true,
            editable: false,
            selectable: false,
            selectMirror: false,
            businessHours: {
                daysOfWeek: [1, 2, 3, 4, 5], // Monday - Friday
                startTime: '09:00',
                endTime: '17:00'
            },
            eventSources: [],
            eventClick: function (info) {
                info.jsEvent.preventDefault();

                if (info.event.extendedProps && info.event.extendedProps.isDetailHidden) {
                    return;
                }

                const sourceCalendar = eventSources.find(es => es.id == info.event.source.id);

                if (typeof eventModal !== 'undefined' && eventModal.show) {
                    eventModal.show(info.event, sourceCalendar);
                } else {
                    console.error('Event modal not available');
                }
            },
            loading: function (isLoading) {
                if (isLoading) {
                    log.debug('Loading calendar...');
                }
            },
            eventSourceFailure: function (error) {
                log.error('Calendar load failed:', error);
            },
            datesSet: function () {
                updateURL();
            }
        });

        calendar.render();
    }

    async function loadCalendars() {
        try {
            const response = await fetch('/api/calendars', {
                credentials: 'include'
            });

            if (!response.ok) {
                log.error('Failed to fetch calendars:', response.status);
                return;
            }

            const calendars = await response.json();

            if (!calendars || calendars.length === 0) {
                log.debug('No calendars to load');
                return;
            }

            // Clear existing event sources
            eventSources.forEach(es => {
                if (es.source) {
                    es.source.remove();
                }
            });
            eventSources = [];

            // Load each calendar
            calendars.forEach(cal => {
                if (!cal || !cal.id) return;

                // Parse events from the pre-processed events field
                let events = [];
                try {
                    if (cal.events) {
                        events = typeof cal.events === 'string'
                            ? JSON.parse(cal.events)
                            : cal.events;
                    }
                } catch (error) {
                    log.error('Failed to parse events for calendar', cal.id, error);
                    events = [];
                }

                log.debug('Loading calendar:', cal.name, 'with', events.length, 'events');

                // Log sample of events for debugging
                if (events.length > 0) {
                    log.debug('Sample events:', events.slice(0, 3).map(e => ({
                        title: e.title,
                        start: e.start,
                        end: e.end,
                        uid: e.uid
                    })));
                }

                // Build FullCalendar events (no need for authentication filtering - backend handles this)
                const fullCalendarEvents = buildFullCalendarEvents(cal, events);

                log.debug('Built', fullCalendarEvents.length, 'FullCalendar events for calendar:', cal.name);

                const source = {
                    id: cal.id,
                    events: fullCalendarEvents,
                    color: cal.color
                };

                const eventSource = calendar.addEventSource(source);

                eventSources.push({
                    id: cal.id,
                    name: cal.name,
                    color: cal.color,
                    source: eventSource,
                    visible: true, // All calendars returned by backend are visible to current user
                    lastUpdate: new Date(),
                    status: 'fresh'
                });
            });

        } catch (error) {
            log.error('Error loading calendars:', error);
        }
    }

    function buildFullCalendarEvents(calendar, events) {
        if (!events || events.length === 0) return [];

        const validEvents = [];
        const skippedEvents = [];

        events.forEach(event => {
            // Skip events without valid start date or title
            if (!event.start && !event.title) {
                skippedEvents.push({ reason: 'No start date or title', event: event.uid || 'unknown' });
                return;
            }

            // Check if this is a detail-hidden event (empty title AND empty description AND empty location)
            const isDetailHidden = event.title === '' && event.description === '' && event.location === '';

            const fcEvent = {
                title: event.title || (isDetailHidden ? '' : 'Untitled Event'),
                start: event.start,
                allDay: event.allDay || false,
                backgroundColor: calendar.color,
                borderColor: calendar.color,
                textColor: 'white',
                extendedProps: {
                    ...buildExtendedProps(event),
                    isDetailHidden: isDetailHidden
                }
            };

            if (event.end) {
                fcEvent.end = event.end;
            }

            if (event.url) {
                fcEvent.url = event.url;
            }

            validEvents.push(fcEvent);
        });

        if (skippedEvents.length > 0) {
            log.debug('Skipped', skippedEvents.length, 'invalid events:', skippedEvents);
        }

        return validEvents;
    }

    function buildExtendedProps(event) {
        const props = {
            description: event.description || '',
            location: event.location || '',
            uid: event.uid || '',
            duration: event.duration || '',
            status: event.status || '',
            transparency: event.transparency || '',
            sequence: event.sequence ? String(event.sequence) : '0'
        };

        // Add timestamp fields if they exist
        if (event.dtStamp) {
            props.dtStamp = event.dtStamp;
        }
        if (event.created) {
            props.created = event.created;
        }
        if (event.lastModified) {
            props.lastModified = event.lastModified;
        }

        // Add organizer information if it exists
        if (event.organizer) {
            if (event.organizer.name) {
                props.organizerName = event.organizer.name;
            }
            if (event.organizer.email) {
                props.organizerEmail = event.organizer.email;
            }
        }

        // Add attendee information if it exists
        if (event.attendees && Array.isArray(event.attendees) && event.attendees.length > 0) {
            const attendeeNames = [];
            const attendeeEmails = [];

            for (const attendee of event.attendees) {
                if (attendee.name) {
                    attendeeNames.push(attendee.name);
                }
                if (attendee.email) {
                    attendeeEmails.push(attendee.email);
                }
            }

            if (attendeeNames.length > 0) {
                props.attendeeNames = attendeeNames.join(', ');
            }
            if (attendeeEmails.length > 0) {
                props.attendeeEmails = attendeeEmails.join(', ');
            }
            props.attendeeCount = String(event.attendees.length);
        }

        return props;
    }

    function linkify(text) {
        if (!text) return text;

        const words = text.split(/(\s+)/);

        return words.map(word => {
            if (/^\s+$/.test(word)) return word;

            let potentialContact = word;
            let trailingPunctuation = '';

            const punctuationMatch = word.match(/^(.+?)([.,;:!?)\]}>]+)$/);
            if (punctuationMatch) {
                potentialContact = punctuationMatch[1];
                trailingPunctuation = punctuationMatch[2];
            }

            const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
            if (emailRegex.test(potentialContact)) {
                return `<a href="mailto:${potentialContact}">${potentialContact}</a>${trailingPunctuation}`;
            }

            const phoneRegex = /^(\+?1[-.\s]?)?\(?([0-9]{3})\)?[-.\s]?([0-9]{3})[-.\s]?([0-9]{4})$/;
            const phoneMatch = potentialContact.match(phoneRegex);
            if (phoneMatch) {
                const cleanPhone = potentialContact.replace(/[^\d+]/g, '');
                return `<a href="tel:${cleanPhone}">${potentialContact}</a>${trailingPunctuation}`;
            }

            try {
                const url = new URL(potentialContact);
                if (url.protocol === 'http:' || url.protocol === 'https:') {
                    return `<a href="${url.href}" target="_blank" rel="noopener noreferrer">${potentialContact}</a>${trailingPunctuation}`;
                }
            } catch (e) { }

            return word;
        }).join('');
    }



    async function refetchAllCalendars() {
        if (!isAuthenticated) {
            passwordModal.show();
            return;
        }

        const confirmed = await confirmModal.warning(
            'Are you sure you want to refetch all calendar data? This may take a moment.',
            'Refetch All Calendars'
        );

        if (confirmed) {
            try {
                const response = await fetch('/api/calendars/refetch', {
                    method: 'POST',
                    credentials: 'include'
                });

                if (response.status === 401) {
                    isAuthenticated = false;
                    passwordModal.show();
                    return;
                }

                if (response.ok) {
                    // Reload calendars after refetch
                    await loadCalendars();
                    toast.success('Calendars refetched successfully!');
                } else {
                    toast.error('Error refetching calendars');
                }
            } catch (error) {
                toast.error('Error refetching calendars: ' + error.message);
            }
        }
    }

    async function checkAuthStatus() {
        try {
            const response = await fetch('/api/auth/verify', {
                method: 'GET',
                credentials: 'include'
            });

            if (response.ok) {
                isAuthenticated = true;
                log.debug('User is authenticated');
            } else {
                isAuthenticated = false;
                log.debug('User is not authenticated');
            }
        } catch (error) {
            isAuthenticated = false;
            log.debug('Auth check failed:', error);
        }
    }

    function waitForModalsToLoad() {
        return new Promise((resolve) => {
            const checkModals = () => {
                if (typeof eventModal !== 'undefined' &&
                    typeof calendarModals !== 'undefined' &&
                    typeof passwordModal !== 'undefined' &&
                    typeof toast !== 'undefined' &&
                    typeof confirmModal !== 'undefined') {
                    resolve();
                } else {
                    setTimeout(checkModals, 10);
                }
            };
            checkModals();
        });
    }

    async function init() {
        await waitForModalsToLoad();
        await checkAuthStatus();
        initCalendar();
        requestAnimationFrame(() => {
            loadCalendars();
        });
    }

    function updateURL() {
        const view = calendar.view;
        const date = calendar.getDate();
        const today = new Date().toISOString().split('T')[0];
        const currentDate = date.toISOString().split('T')[0];

        let viewName;
        switch (view.type) {
            case 'dayGridMonth':
                viewName = 'month';
                break;
            case 'timeGridWeek':
                viewName = 'week';
                break;
            case 'timeGridDay':
                viewName = 'day';
                break;
            case 'listMonth':
                viewName = 'list';
                break;
            default:
                viewName = 'week';
        }

        const url = new URL(window.location);
        url.searchParams.set('view', viewName);

        if (currentDate !== today) {
            url.searchParams.set('date', currentDate);
        } else {
            url.searchParams.delete('date');
        }

        window.history.replaceState({}, '', url.toString());
    }


    document.addEventListener('DOMContentLoaded', () => {
        init();
    });
</script>
